The provided article is a detailed and strong rebuttal to an "amateurish white-paper" that claimed Groovy was not Enterprise-ready. The author of the article asserts that the original white paper was inaccurate, lacked proper research, and served primarily to spread FUD (Fear, Uncertainty, Doubt) rather than offering a valid technical assessment. The article systematically addresses and refutes several key claims made by the original paper, aiming to prove Groovy's maturity and suitability for enterprise use.

The author begins by stating that while he would welcome accurate criticism to improve Groovy, the original article failed to provide it. Instead of delving into technical details already explained by Graeme Rocher, the author focuses on commenting on specific claims:

1.  **Groovy as a Java Replacement:** The original white paper suggested that "some" claim dynamic languages like Groovy should replace Java. The author clarifies that this is not his stance. He emphasizes that Groovy was initially conceived to *complement* Java, not replace it, and advocates for developers to choose "the best tool for the job." He acknowledges Java as a "great language, and a wonderful platform" that is thread-safe, optimizes database access, and scales exceptionally well. While acknowledging that Groovy can be used for full projects (as demonstrated by the Grails framework), its role is typically complementary.

2.  **Enterprise Adoption:** The white paper mentioned SAP's use of Groovy and Grails for a new community-driven product. The author turns this into a powerful argument for Groovy's enterprise readiness, highlighting that major vendors like SAP, IBM, Oracle, and JBoss have chosen Groovy and Grails for innovative projects. He challenges the notion that such large corporations would adopt these technologies if they were not deemed enterprise-ready, providing links to SAP's testimonials and project details as evidence.

3.  **Sun Microsystems' Backing:** The original paper highlighted Sun Microsystems' investment in JRuby, including hiring its lead developers and extensive marketing. The author clarifies that Sun has also significantly supported the Groovy project. This support includes providing a Sun Fire T2000 machine for performance testing, facilitating the creation of a Java Specification Request (JSR) to standardize Groovy in the Java Community Process (JCP), and actively working on Groovy and Grails support within NetBeans IDE. He attributes the perceived difference in backing primarily to less marketing budget being allocated to Groovy and Grails.

4.  **Evaluation of Suitability and Reliability:** The author agrees with the general sentiment that the suitability and reliability of Groovy or JRuby should be "evaluated seriously" before enterprise application. However, he stresses that this evaluation should involve "doing your own homework" and assessing technical solutions in a "realistic context," rather than blindly trusting "micro-benchmarks or amateurish white-papers."

5.  **Maturity and Production Confirmation:** One of the most critical claims from the white paper was that Groovy and JRuby are "still very young and has not yet been confirmed in production." While the author refrains from commenting on JRuby's production status, he vehemently refutes this for Groovy. He provides several concrete examples of Groovy's successful use in "mission-critical applications" within high-profile organizations:
    *   A London financial institution handling "million-dollars hedge funds daily."
    *   US Fortune 500 insurance company Mutual of Omaha, which uses Groovy for a risk calculation engine with "thousands of lines of Groovy business rules."
    *   The US National Cancer Institute, which utilizes Groovy to "validate patients file details."
    *   One of the "top major American credit card company" (a Fortune 500 top 20 company) leveraging Groovy in production.
    These examples are presented as irrefutable proof of Groovy's proven enterprise readiness and maturity.

6.  **Memory Leakage Claims:** The white paper alleged that the "Groovy runtime is not stable" due to "memory leakage," with memory consumption increasing linearly. The author categorically denies this, stating, "There is no leakage of memory in Groovy at all." He explains that when a script is evaluated at runtime, a new class is created, and the classloader retains this class to avoid the cost of recompilation if it's needed again. He clarifies that if a script is intended for single execution, users should simply discard the classloader or the Groovy shell afterward. He attributes the "leakage" claim to a misunderstanding of how Groovy's APIs are intended to be used.

7.  **JBoss-Specific Memory Issues:** The white paper further suggested that certain server environments, like JBoss Application Server, might exacerbate memory issues by not unloading classes. The author admits he lacks sufficient knowledge of JBoss internals to comment definitively but expresses skepticism. He suspects that JBoss infrastructure would allow Groovy's classloader to be garbage collected, otherwise, it would be "mostly impossible to make serious applications work on JBoss AS." He invites more knowledgeable JBoss experts to comment on this point.

In conclusion, the article firmly asserts that Groovy has been "very stable and mature for a long time already" and is successfully "used by many high-profile companies and institutions throughout the world." The author condemns the original white paper as an unresearched attempt to spread FUD. The article also includes updates pointing to an additional technical analysis for those seeking a deeper understanding of Groovy's memory and classloading behavior.