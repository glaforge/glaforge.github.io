This article thoroughly explores the evolving role and appropriate scope of API definition languages, such as Swagger/OpenAPI Spec, RAML, and API Blueprint. While these languages currently excel at defining the fundamental *structure* of an API—including endpoints, resources, parameters, headers, status codes, and security schemes—the industry is actively scrutinizing their purpose and design, particularly concerning their extensibility with additional elements and feature sets.

A recent debate within the OpenAPI Specification community, centered around "Open World vs. Closed World" principles, highlights the core tension: should an API definition strive for a complete, exhaustive description of an API (e.g., including inaccessible paths or all possible status codes), or should it serve as a "best effort" to describe only what is usable and necessary for most consumers? This overarching question prompts the article to ask: how detailed should API definitions truly be?

The author suggests numerous potential enhancements and "dreamed up" uses for API definition languages beyond their current structural focus:

1.  **Enriched Documentation and Metadata:** API definitions could incorporate more narrative and metadata to describe the flow of API calls and user interactions, potentially enhancing API discovery and even including copyright information (perhaps linking to external descriptors like APIs.json).
2.  **Media Type Agnostic Data Models:** They could define data models independently of specific media types (like JSON or XML schemas), allowing consumers to request various output formats while still understanding the intrinsic nature of the resources. MSON (Markdown Syntax for Object Notation) is cited as an example of this approach.
3.  **Reusable Common Traits:** Common API patterns, such as pagination, could be factored into a reusable and referenceable fashion within the definitions.
4.  **Improved Hypermedia Support:** Current specifications often fall short in modeling hypermedia APIs, a key tenet of REST (HATEOAS). The article suggests future versions could better support defining hypermedia links using approaches like HAL, JSON-LD, or Siren.
5.  **Conformance and Tooling:** Definitions could contribute to ensuring API implementations conform to their definitions, company guidelines, or best practices (like PayPal's API style guide). This would necessitate new formats for declaratively defining rules and accompanying tooling for automated validation.

The article then delves into several of these propositions in more detail, questioning whether they fall within the intended purpose of an API definition language:

*   **API Storytelling and Multi-Step Transactions:** API providers often need to explain complex use cases involving "chained calls" (multiple API calls in sequence, where responses from one inform subsequent requests). While current definitions allow descriptions of parameters, they lack the ability to model a "cohesive workflow" or "API stories" for these multi-step transactions.
*   **Test Scenarios:** Closely related to storytelling, the ability to derive or embed test scenarios directly within API definitions would be highly beneficial, potentially integrating with continuous integration pipelines. API Blueprint's roadmap, for instance, already lists scenarios and testing.
*   **Documentation vs. Specification:** The article clarifies that while distinct, API definition formats are intimately linked to API documentation. The presence of description tags in definitions proves they are not solely for machine consumption. Definitions can generate not only client SDKs and server skeletons but also static or interactive HTML documentation and even power full API developer portals.
*   **Style Guide, Conformance, and Tooling:** The article argues for automatic assessment of an API's conformance to organizational style guides. This could involve defining guidelines within the API definition itself or in a referenced external document, requiring new formats (declarative or scripting-based) and specialized tooling to check for adherence.
*   **Hypermedia:** Despite its popularity, hypermedia as the engine of application state (HATEOAS) is often poorly supported by existing API definition languages. The article asks if definitions should better facilitate describing hypermedia links and metadata, noting API Blueprint's MSON capabilities for HAL as a positive step.
*   **Data and Payload Modeling:** The discussion around MSON and Apigee's Rapier (for data-oriented APIs with relationships) raises the question of how prescriptive API definitions should be regarding data modeling. Should they aim to support any possible payload, or focus on the "80/20 sane use cases"?

The article acknowledges that while many of these "bells and whistles" are not natively supported, **API definition extensions** (like Swagger/OpenAPI's `x-` vendor extensions) offer a current workaround. These allow designers to embed custom data or metadata, enabling tools to process these specific extensions. However, a significant downside is their proprietary nature; they are not universally understood by all tools and vendors, limiting portability and standardization.

In its **final thoughts**, the article circles back to its central dilemma: should API definition languages aim to be comprehensive, providing "everything and the kitchen sink," or should they primarily stick to describing core API elements, leveraging complementary formats like APIs.json for additional resources? While extensions offer a path forward—especially if defined, published, and shared in a somewhat standardized fashion—many still perceive a need for greater native expressivity than what is currently offered. The article concludes by inviting readers to weigh in on where the "cursor" should be placed regarding the detail level of API definitions.