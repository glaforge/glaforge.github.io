This article, part two of a series on mastering agentic workflows with the ADK for Java, introduces the **`SequentialAgent`** as a powerful tool for orchestrating AI agents in scenarios where the process itself dictates a fixed, linear sequence of steps. This contrasts with the "divide and conquer" strategy using flexible sub-agents discussed in the first part, where an orchestrator LLM dynamically directs the conversation flow based on user input.

### The Need for Sequential Workflows

The article highlights that many tasks are inherently linear, requiring steps to be executed in a specific order—much like a CI/CD pipeline (build, test, deploy). For such predictable, step-by-step processes, the `SequentialAgent` provides a robust solution. Unlike the more dynamic sub-agent model where an orchestrator LLM decides which agent to invoke and when, a `SequentialAgent` executes a predefined list of agents in a strictly enforced order.

This sequential approach is particularly useful for:
*   **Automating multi-step processes:** Guiding users or systems through a fixed procedure, such as a trip planner or a complex data analysis pipeline.
*   **Ensuring consistency:** Guaranteeing that tasks are always performed in the correct sequence, leading to reliable and predictable outcomes.
*   **Building on previous results:** Creating workflows where the output of one step serves as the essential input for the subsequent step, fostering a chain of dependent operations.

### Practical Example: The `trip-planner`

To illustrate the `SequentialAgent` in action, the article presents a `trip-planner` example. This agent helps users plan a vacation by breaking down the complex task into three specialist sub-agents, executed in a specific, logical order:

1.  **`destination-researcher`**: This initial agent takes the user's request (e.g., "a romantic weekend in Paris") and, using the `GoogleSearchTool`, identifies suitable attractions and points of interest based on the destination and travel style. Its final output is stored for subsequent use.
2.  **`itinerary-creator`**: Following the research phase, this agent takes the list of attractions generated by the `destination-researcher` and organizes it into a logical, day-by-day plan. Its output, the detailed itinerary, is then passed to the next agent.
3.  **`restaurant-suggester`**: As the final step, this agent receives the complete itinerary. It then uses the `GoogleSearchTool` to find and suggest relevant lunch and dinner recommendations that are near the day's activities and align with the overall travel style, enriching the itinerary.

The full Java source code for these `LlmAgent` instances and their orchestration by the `SequentialAgent` is provided, demonstrating how each agent is configured with a name, description, instructions, model (`gemini-2.0-flash`), and sometimes tools.

### The Magic of State Passing: `outputKey`

A core mechanism enabling `SequentialAgent` functionality is the elegant system for **passing state between agents** using an `outputKey`.

*   **Producer Agent:** An agent that generates data crucial for subsequent steps is configured with an `.outputKey("some-key")` method. This instructs the `SequentialAgent` to store the agent's final conversational output in a context variable accessible by this key. For example, `destinationResearcher` uses `outputKey("destination-research")`.
*   **Consumer Agent:** A subsequent agent in the sequence can then easily reference this stored data directly within its instructions using curly braces: `{some-key}`. The ADK automatically injects the full output of the producer agent into the consumer's prompt before it's sent to the LLM. For instance, `itineraryCreator` consumes `{destination-research}` and `restaurantSuggester` consumes `{itinerary}`. This allows agents to seamlessly build upon the work of their predecessors, maintaining context and continuity throughout the workflow. The article notes that the last agent can reference the output of any previous agent, not just the immediately preceding one, for full context awareness.

### Building the `SequentialAgent`

Constructing a `SequentialAgent` is straightforward using `SequentialAgent.builder()`. The predefined sub-agents are passed to the `.subAgents()` method in the desired order. The crucial point here is that **the order specified is strictly enforced**. When the `trip-planner` agent runs, it first executes `destinationResearcher`, feeds its output to `itineraryCreator`, then feeds `itineraryCreator`'s output to `restaurantSuggester`, and finally returns the comprehensive, enriched itinerary to the user.

### Example Run Analysis

The article provides a detailed example run of the `trip-planner` for a "5-day trip in Paris, with a medium budget, to visit key tourist attractions and eat French cuisine."

*   The **`destination-researcher`** successfully uses Google Search to find relevant attractions, parks, dining options, and provides an initial itinerary outline along with general budget tips.
*   The **`itinerary-creator`** then takes this research and constructs a highly detailed, day-by-day itinerary, including timings, estimated budgets for activities, and general travel tips, elaborating on the initial suggestions.
*   Finally, the **`restaurant-suggester`** takes the detailed itinerary and integrates specific restaurant recommendations for lunch and dinner each day, using Google Search to find establishments near the planned activities that match the budget and French cuisine preference. The output demonstrates how it suggests specific places like `Crêperie Générale` or `Le Bouillon Chartier`, while also pointing out limitations such as needing accommodation location for a specific recommendation or instances where budget might lead to non-French or on-the-go suggestions. The overall assessment is that the "culinary expert gave some good suggestions."

### When to Choose `SequentialAgent` vs. Flexible Sub-Agents

The article concludes by providing clear guidance on when to opt for each agent type:

*   **Choose a `SequentialAgent`** when you have a fixed, linear process where each step logically depends on the output of the previous one. It provides predictability, structure, and ensures a consistent flow.
*   **Choose an `LlmAgent` with sub-agents** (as discussed in Part 1) when you need flexibility, allowing an orchestrator LLM to dynamically decide the best tool or next step based on the evolving conversational context and user intent.

By understanding and effectively utilizing both sequential and flexible agent patterns, developers can construct highly robust and sophisticated AI systems tailored precisely to the specific problem requirements. The article also teases the next part of the series, which will explore running agents in parallel.