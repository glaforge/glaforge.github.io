---
title: "Groovy 1.8.3 and 1.9-beta-4 released"
date: "2011-10-12T00:00:00.000+02:00"
tags: [groovy]
---

The [Groovy](http://groovy.codehaus.org) development team has just released Groovy 1.8.3 and 1.9-beta-4.  

For the impatients:

*   download it on the [Groovy download page](http://groovy.codehaus.org/Download)
*   check the [JIRA release notes for 1.8.3](http://jira.codehaus.org/secure/ReleaseNote.jspa?projectId=10242&version=17657) and [1.9-beta-4](http://jira.codehaus.org/secure/ReleaseNote.jspa?projectId=10242&version=17656)
*   or read the [official announcement](http://markmail.org/message/ugk5244bdqkzxfil)

Those two releases are essentially about bug fixes and minor enhancements, but we also have interesting developments going on for static type checking your Groovy code, and for invoke dynamic support for performance of our dynamic core. But it'll be better that I save those topics for some future posts!  

Here, I just wanted to highlight some of the minor enhancements in those two new releases. Such enhancements sometimes go unnoticed, so I thought it would be nice to put them a bit more in the spotligh.  

Customize your groovysh prompt A pretty [old request](http://jira.codehaus.org/browse/GROOVY-2832) was about the ability to customize your groovysh prompt, so that instead of `groovy`, you could have your own message. This can be handy for people reusing the groovy shell infrastructure to embed that somehow in their applications, offering various pre-defined variables in the binding, etc.  

If you want to customize your groovysh prompt, there are two approaches: either you export an environement variable called `GROOVYSH_PROMPT`, or you pass the `-Dgroovysh.prompt=myMessage` argument to your groovysh launch command.  

Here's a screenshot showing how one can use fancy characters from a Mac OS X console:  

![](/img/misc/groovysh+prompt.png)  

Launching remote Groovy scripts The groovy command usually takes a file as argument, pointing at the script or class you want to run. But it's now also possible to run remote scripts available on the net somewhere.  

For example, with the [Groovy Web Console](http://groovyconsole.appspot.com), scripts can be viewed with the following URL: [http://groovyconsole.appspot.com/script/110001](http://groovyconsole.appspot.com/script/110001). But there's also another URL that you can use to get the raw content of that script: [http://groovyconsole.appspot.com/raw/110001](http://groovyconsole.appspot.com/raw/110001).  

So just type the following, to run a remote Hello World script!

```bash
groovy http://groovyconsole.appspot.com/raw/110001
```

And it'll just print hello on the console.  

As a little warning though, don't run blindly any remote script that someone sends you the link of :-)  

Formatting dates for a specific time zone Groovy's had some nice shortcuts for quickly formatting dates and calendar instances. And there's a new little variant for printing a particular date and time according to a certain time zone.  

I'm currently in GMT+2, and I want to print the current date and time with my particular time zone, here's how I could do it:

```groovy
def d = new Date()  
def tz = TimeZone.getTimeZone('GMT+2')  
println d.format('yyyy-MM-dd HH:mmZ', tz)  
// prints for me now: "2011-10-13 00:53+0200"
```

Now onto two new features which are exclusively on Groovy 1.9.  

Viewing the generated bytecode from the Groovy console This capability is probably more interesting for the Groovy developers themselves, as most of your time, you won't really need to know what the groovy compiler generates in terms of bytecode â€” not even mentioning that this might be a little bit scary. But if you're using the Groovy Swing console, that you're launching the AST browser, it'll show you the bytecode as well, as shows the following screenshot. 

![](/img/misc/bytecode+view.png) 

So first step, launch your Groovy console with the groovyconsole command. Then open a script or class whose bytecode you want to have a look at. Click on the AST browser menu item, or hit `CTRL-T`. At that point, make sure you use the "class generation" phase from the drop-down box, and also select a _class node_ in the AST tree (otherwise you won't see any bytecode at all).  

Control over Global AST Transformations Global AST transformations like Grape's or the AST builder are not necessarily needed when you embed Groovy in your application. They incur a pretty small overhead of compilation time. Or perhaps on your classpath you use a library that has a global transform but that you are not using and don't want to be impacted by it. Now you are able to disable such transformations through the CompilerConfiguration object.  

Here's an excerpt of our unit test covering this new capability:

```groovy
import org.codehaus.groovy.control.CompilerConfiguration  

def config = new CompilerConfiguration()  

config.disabledGlobalASTTransformations =   
    ['org.codehaus.groovy.ast.builder.AstBuilderTransformation']  

def script = '''  
    import org.codehaus.groovy.ast.builder.AstBuilder  
    new AstBuilder().buildFromCode { "Hello" }  
'''

// witout a specific configuration, the AST builder works  
def shell = new GroovyShell()  

assert shell.evaluate(script).class == ArrayList  

// now with the configuration in place,   
// the AST builder transform is not applied  
shell = new GroovyShell(config)  

shouldFail {  
    shell.evaluate(script)  
}
```