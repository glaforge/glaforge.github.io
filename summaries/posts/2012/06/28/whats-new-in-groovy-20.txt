Groovy 2.0 introduces a significant update to the dynamic language, focusing on three key themes: enhanced static capabilities, alignment with JDK 7 improvements, and increased modularity. These changes aim to boost performance, improve "Java friendliness" and developer feedback, and streamline the language's distribution.

### A "Static Theme" for a Dynamic Language: Static Type Checking and Compilation

While Groovy remains fundamentally a dynamic language, Groovy 2.0 addresses the needs of Java developers who often use it as a "better Java" or scripting language within Java applications. These users frequently desire the compile-time feedback and type safety of `javac` rather than encountering runtime errors.

**Static Type Checking:**
Groovy 2.0 introduces optional **static type checking** via the `@TypeChecked` annotation, which can be applied at the method or class level. This feature, built on Groovy's AST (Abstract Syntax Tree) transformation mechanisms, provides immediate compilation errors for common issues like:
*   **Typographical errors:** Misspellings of variable or method names. For example, calling `sommeeMethod()` instead of `someMethod()` would yield a compilation error.
*   **Incorrect type assignments and return values:** The checker verifies that assigned values match variable types (e.g., cannot assign a `Date` to an `int`) and that method return types are respected. It also demonstrates type inference, understanding that `letters[0]` in a `String[] letters` array is of type `String`.
*   **Control flow type checking:** It can infer types returned from `if/else`, `try/catch`, or `switch/case` blocks, catching inconsistencies like a `String` return in an `int` method.

The static type checker is intelligent enough to allow Groovy's common automatic type conversions (e.g., non-empty `String` to `true` for `boolean` returns, `StringBuilder` to `String`, `String` class names to `Class` objects). It also leverages **type inference** extensively, understanding types even when variables are declared with `def` (e.g., `def name = "Guillaume"` infers `name` is a `String`), and recognizing GDK (Groovy Development Kit) methods.

An important aspect is the ability to **mix dynamic and statically typed code**. Since many dynamic features (like runtime method additions) cannot be statically checked, developers can opt out of type checking for specific methods using `@TypeChecked(TypeCheckingMode.SKIP)` when the rest of the class is type-checked.

Further advanced inference includes:
*   **`instanceof` checks:** After an `instanceof` check within an `if` block, the type checker automatically infers the narrowed type of the variable, eliminating the need for explicit casts common in Java.
*   **Lowest Upper Bound:** For collections containing different but related types (e.g., `[1234, 3.14]` which contains `Integer` and `BigDecimal`), the checker infers a "lowest upper bound" type, such as `List<Number & Serializable & Comparable>`, providing a more granular understanding of the collection's contents.
*   **Flow Typing:** The compiler's "flow typing" algorithm tracks variable types through assignments. If a variable's type changes, the checker adapts, but if a variable's type might unpredictably change at runtime (e.g., within a closure based on a random condition), the checker will err on the side of caution and flag potential type conflicts. However, if a common supertype can be definitively inferred (e.g., a variable starting as `A` and potentially becoming `B extends A` in a closure), the checker will allow methods of the common supertype.

These static type checks occur at compile-time, but the generated bytecode remains the same dynamic code as before, meaning no behavioral changes at runtime.

**Static Compilation:**
Building on static type checking, Groovy 2.0 introduces **static compilation** using the `@CompileStatic` annotation. This is a significant performance feature, especially for users not on JDK 7 (which has `invoke dynamic`).
*   **Performance:** Code annotated with `@CompileStatic` generates bytecode that closely resembles `javac` output, leading to execution speeds comparable to plain Java. Benchmarks show performance identical in many cases, sometimes slightly slower. This eliminates the need to rewrite performance-critical sections in Java, allowing entire projects to be written in Groovy.
*   **Bytecode Size:** Statically compiled methods produce smaller bytecode because they do not include the additional instructions required for Groovy's dynamic runtime system.
*   **Shielding from "Monkey Patching":** Static compilation bypasses Groovy's dynamic runtime, protecting code from unintended interactions or conflicts caused by runtime metaprogramming (e.g., two libraries adding conflicting methods to a core class).
*   **AST Transforms:** Crucially, static compilation still fully supports Groovy's powerful AST transformation mechanisms, as these operate at compile time.

Like `@TypeChecked`, `@CompileStatic` can be applied to classes or methods, and individual methods can opt out using `@CompileStatic(SKIP)`.

### The Java 7 and JDK 7 Theme: Project Coin and Invoke Dynamic

Groovy's close syntactic relationship with Java is a key factor in its adoption. Groovy 2.0 embraces new features from JDK 7 to maintain this familiarity and leverage JVM advancements.

**Project Coin Syntax Enhancements:**
Groovy 2.0 adopts several "Project Coin" syntax improvements introduced in Java 7, enhancing readability and reducing verbosity:
*   **Binary Literals:** Numbers can now be represented in binary using the "0b" prefix (e.g., `0b10101111`).
*   **Underscore in Number Literals:** Underscores can be placed within numeric literals (e.g., `1234_5678_9012_3456L`) to improve readability and group digits.
*   **Multi-Catch Block:** A single `catch` block can now handle multiple exception types, reducing code duplication (e.g., `catch(IOException | NullPointerException e)`).
Groovy already supported some Project Coin features like `Strings` in `switch` statements. The only notable omission is "try-with-resources," for which Groovy already offers robust alternatives through its GDK.

**Invoke Dynamic Support:**
JDK 7 introduced the "invoke dynamic" (indy) bytecode instruction and associated APIs (call sites, method handles, class values) specifically designed to aid dynamic language implementors on the JVM. Groovy 2.0 can leverage this:
*   **Benefits:** It simplifies the implementation of dynamic method calls and promises performance improvements by enabling better caching and optimization within the JVM.
*   **Usage:** To use `invoke dynamic`, developers must use specific "indy" JARs (identifiable by the "-indy" classifier) and enable the feature during compilation (e.g., with the `--indy` flag for `groovyc`, an `indy="true"` attribute in the Ant task, or via `CompilerConfiguration` in `GroovyShell`). When enabling indy, primitive optimizations should be disabled as indy aims to be a full replacement for dynamic method dispatch.
*   **Performance:** While `invoke dynamic` holds great promise, its performance in initial Groovy 2.0 tests was mixed; some areas saw gains, others ran slower. The article notes that the JVM's optimization for `invoke dynamic` was still maturing at the time of release, with improvements expected in future JDK 7 updates and particularly with JDK 8's adoption of `invoke dynamic` for Lambdas.

### A More Modular Groovy

Groovy is not just a language but also a rich set of APIs for various tasks. Historically, all these features were bundled into a single large JAR, which was inefficient for applications needing only a subset of functionalities.

**Groovy Modules:**
Groovy 2.0 addresses this by splitting the core Groovy JAR into smaller, specialized modules. The core JAR is now significantly smaller, and specific features are distributed as separate JARs. Examples include:
*   **Ant, BSF, Console, GroovyDoc, Groovysh, JMX, JSON, JSR-223, Servlet, SQL, Swing, Templates, Test, TestNG, XML.**
This modularization allows developers to include only the necessary components in their projects, reducing classpath size and facilitating integration into environments like mobile applications (e.g., Android). An "all" JAR is still provided for convenience. Indy versions of these modular JARs are also available.

**Extension Modules:**
This modularization effort also yielded the **extension module** feature, which provides a formal mechanism for adding new instance and static methods to existing classes, including those from the JDK or third-party libraries. Groovy itself uses this to enhance JDK classes (e.g., `String`, `File`, `URL`).
*   **Creation:** To create an extension, developers write helper classes (in Groovy or Java) containing `public static` methods. For instance methods, the first parameter is the `self` instance on which the method will be called. For static methods, the first parameter typically represents the class itself, or isn't needed if the method doesn't operate on an instance.
*   **Example (Instance Method):** To add a `greets()` method to `String`, a helper method like `static String greets(String self, String name)` is created.
*   **Example (Static Method):** To add a `between()` method to `Random`, a helper method like `static int between(Random selfType, int start, int end)` is created.
*   **Descriptor:** An `org.codehaus.groovy.runtime.ExtensionModule` file in `META-INF/services` of the module archive defines the module's name, version, and points to the helper classes for instance and static extensions.
*   **Usage:** Once an extension module with its descriptor is on the classpath, the extension methods are automatically registered and available without special imports. This also integrates with `@Grab` annotations, meaning extension methods are installed automatically when their module is grabbed as a dependency. These extension methods are also understood by the static type checker and compiler.

**Conclusion:**
Groovy 2.0 marks a pivotal release, reinforcing its position as a powerful and friendly language on the Java platform. By introducing optional static type checking and compilation, it addresses performance concerns and developer feedback needs, making Groovy a more viable option for entire application codebases, even performance-critical ones. Its embrace of JDK 7 features ensures continued synergy with the Java ecosystem, while enhanced modularity provides greater flexibility and efficiency in application design and deployment.