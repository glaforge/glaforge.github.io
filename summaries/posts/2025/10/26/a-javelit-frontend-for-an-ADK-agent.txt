This article details the author's continued exploration of Javelit, a Java framework for quickly building interactive web frontends, by demonstrating its integration with Google's Agent Development Kit (ADK) for Java. Following previous successful attempts at creating a frontend for image generation and a chat interface for a LangChain4j-based Gemini model, the author set out to connect a Javelit frontend with an ADK search agent.

The core of the article revolves around building a simple web interface with Javelit that interacts with a sophisticated ADK agent.

**The Javelit Interface:**
The user interface built using Javelit is intentionally minimalist, comprising three key components:
1.  **A Title:** Displaying "ADK Search Agent" with relevant emojis.
2.  **A Container:** A bordered area designated to display the agent's responses.
3.  **A Text Input Field:** Where users can enter their search queries.

**The ADK Agent:**
For this demonstration, a straightforward ADK search agent was constructed. This agent is designed to be a "helpful search assistant" capable of leveraging two distinct search tools:
1.  **Google Search Tool:** Used for retrieving up-to-date information from the web.
2.  **Google Maps Tool:** Utilized for searching geographical details, landmarks, points of interest, and establishments like restaurants.
    *   A notable detail is that the author recently contributed the `GoogleMapsTool` to ADK for Java, meaning it might not be immediately available in public releases and might require building ADK from source or waiting for a future release.

The ADK agent's code defines an `LlmAgent` named "gemini-search-agent." It's configured with clear instructions on when to use each tool and specifies the `gemini-2.5-flash` model for its underlying language capabilities. The two tools, `GoogleSearchTool` and `GoogleMapsTool`, are directly wired into the agent's definition.

**Agent Setup and Interaction Mechanism:**
To enable interaction with the ADK agent, the article details the necessary setup:
*   `InMemorySessionService` and `InMemoryArtifactService` are initialized to manage agent sessions and artifacts.
*   A `Runner` instance is created, encapsulating the agent, its name, and the session/artifact services. The `Runner` orchestrates the agent's execution.
*   A unique `userId` is generated, and a `Session` is created for this user via the `Runner`'s session service.
*   To keep these crucial interaction components (`Runner`, `userId`, `Session`) together and facilitate their re-use, a Java `record` named `AgentRunnerSession` is defined. A helper method, `getAgentSession()`, is responsible for initializing and returning an instance of this record.

**Building the UI and Maintaining State with Javelit:**
A critical aspect of integrating with Javelit is understanding its execution model: the UI layout code within the `main` method is re-run with every user interaction. To maintain the conversational state with the ADK agent across these re-runs, the `AgentRunnerSession` object (holding the agent's `Runner` and `Session`) is stored within Javelit's session state. The `Jt.sessionState().computeIfAbsent()` method ensures that the `AgentRunnerSession` is created only once when the application starts for a given user and subsequently retrieved from the session state for all follow-up interactions.

The Javelit UI components (`Jt.title`, `Jt.container`, `Jt.textInput`) are then initialized. When a user types a query into the `textInput` field and hits Enter, the `searchQuery` variable captures the input.

**Processing User Input and Agent Responses:**
Upon receiving a non-empty `searchQuery`, the interaction with the ADK agent is initiated. The `holder.runner().runAsync()` method is called with the user's ID, session ID, and the query encapsulated as `Content.fromParts(Part.fromText(searchQuery))`. This method returns a reactive stream of events. The `blockingForEach()` operator is then used to iterate through each event generated by the agent. For every event, its content is converted to a string (`event.stringifyContent()`) and displayed as Markdown within the designated `eventContainer` in the Javelit frontend.

**Conversational State Management in the ADK Agent:**
An important conclusion highlighted is that while the simple Javelit UI in this example only displays the latest agent response (not the full conversation history), the ADK agent itself *retains the conversational state*. This means that if a user first asks about a restaurant and then follows up with a question like "What are its opening times?", the agent remembers the context of the previous query and correctly interprets "its" as referring to the restaurant previously mentioned.

**Overall Conclusion:**
The author concludes by noting another successful integration with Javelit. Despite an initial perception of ADK's "unusual approach" compared to more event-driven web frameworks, the author expresses appreciation for Javelit's simplicity, which makes it highly effective for quickly building interactive frontends and experimenting with ideas. The article ends with an anticipation of further exploration into Javelit's other features and components for future projects and presentations.