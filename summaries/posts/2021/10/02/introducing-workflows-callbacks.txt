This article introduces **Workflows callbacks**, a significant new feature designed to enhance the orchestration capabilities of Google Cloud Workflows by allowing workflow executions to pause and wait for external events or human input, rather than relying on inefficient polling mechanisms.

Google Cloud Workflows currently enables developers to orchestrate various services on Google Cloud or third-party APIs. It leverages connectors for managing long-running Google Cloud operations and includes a built-in `sys.sleep` function for time-based waits or for waiting until some computation finishes. However, the article identifies a limitation: waiting for explicit user input or notifications from external systems (like a fulfillment center or inventory system) typically requires a cumbersome combination of "sleep" instructions and API polling. Workflows callbacks directly address this by allowing a workflow execution to explicitly *wait* until it receives a call to a specific, unique callback endpoint.

To illustrate this new capability, the article presents a detailed case study involving the **human validation of machine-translated text**. While machine learning translations are highly advanced, there are scenarios where human oversight or approval is desired. The proposed architecture uses Workflows callbacks to insert this human (or autonomous system) validation step into the workflow:

1.  **User Interaction:** A user visits a translation webpage, enters text, and clicks a "translate" button.
2.  **Workflow Initiation:** Clicking the button triggers a Cloud Function, which in turn launches a Workflows execution, passing the input text as a parameter.
3.  **Translation and Display:** The workflow saves the original text to Cloud Firestore. It then calls the Translation API, stores the generated translation in Firestore, and the translation is displayed on the webpage in real-time using the Firebase SDK.
4.  **Callback Endpoint Creation:** A crucial step in the workflow is the creation of a unique **callback endpoint**. The details of this endpoint (specifically its URL) are saved to Firestore, which then triggers the webpage to display "validate" and "reject" buttons to the user.
5.  **Workflow Pause:** The workflow then explicitly invokes an "await callback" step, which **pauses its execution** until the created callback endpoint is called.
6.  **User Decision & Callback Trigger:** The user reviews the translation and decides to either validate or reject it by clicking the respective button. This action calls another Cloud Function, passing the approval status. This Cloud Function then calls the specific callback endpoint that the workflow is awaiting, also passing the approval status.
7.  **Workflow Resumption:** Upon receiving the call to its callback endpoint, the workflow **resumes execution**. It saves the user's approval status to Firestore and completes.

The article details the technical implementation of callbacks through two new built-in functions introduced in the standard Workflows library:

*   **`events.create_callback_endpoint`**: This function is used to create and set up the callback endpoint. Developers specify the HTTP method (e.g., "POST") that should be used for invoking the endpoint. The function returns a dictionary containing the endpoint's details, including its unique URL, which can then be passed to other systems (like Firestore for the webpage to access).
*   **`events.await_callback`**: This function is used to pause the workflow and wait for the callback endpoint to be called. It takes the callback endpoint details (obtained from `create_callback_endpoint`) and a `timeout` parameter (in seconds) defining how long the workflow should wait. When the endpoint is called, the function returns a dictionary containing the full details of the incoming HTTP request, including its headers and body. If the specified timeout is reached before the callback is received, a `TimeoutError` is raised, which can be handled by a `try/except` block.

YAML examples demonstrate how these functions are integrated into a workflow definition. For instance, `create_callback` specifies `http_callback_method: "POST"` and stores the result in `callback_details`. Subsequently, `await_callback` uses `${callback_details}` and sets a `timeout` (e.g., `3600` seconds), storing the received request's information in `callback_request`.

In conclusion, Workflows callbacks provide a powerful and elegant solution for building interactive and event-driven workflows that require external input, human approval, or synchronization with third-party systems. The feature is currently in preview, requiring users to request access. The article provides links to the example code, a tutorial, documentation, and contact information for feedback.