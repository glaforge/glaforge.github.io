<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>best-practices on Guillaume Laforge</title><link>https://glaforge.github.io/tags/best-practices/</link><description>Recent content in best-practices on Guillaume Laforge</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright><lastBuildDate>Wed, 01 Feb 2023 23:31:37 +0100</lastBuildDate><atom:link href="https://glaforge.github.io/tags/best-practices/index.xml" rel="self" type="application/rss+xml"/><item><title>Google Cloud Workflows API automation, patterns, and best practices</title><link>https://glaforge.github.io/talks/google-cloud-workflows-api-automation-patterns-best-practices/</link><pubDate>Wed, 01 Feb 2023 23:31:37 +0100</pubDate><guid>https://glaforge.github.io/talks/google-cloud-workflows-api-automation-patterns-best-practices/</guid><description> Workflows at a glance, benefits, key features, use cases UI interface in Google Cloud console Deep dive into the Workflows syntax Workflows connectors Demos Patterns and best practices</description></item><item><title>Choreography vs Orchestration in Microservices and Best Practices</title><link>https://glaforge.github.io/talks/choreography-vs-orchestration-in-microservices-and-best-practices/</link><pubDate>Thu, 20 Oct 2022 21:56:33 +0100</pubDate><guid>https://glaforge.github.io/talks/choreography-vs-orchestration-in-microservices-and-best-practices/</guid><description>We went from a single monolith to a set of microservices that are small, lightweight, and easy to implement. Microservices enable reusability, make it easier to change and scale apps on demand but they also introduce new problems. How do microservices interact with each other toward a common goal? How do you figure out what went wrong when a business process composed of several microservices fails? Should there be a central orchestrator controlling all interactions between services or should each service work independently, in a loosely coupled way, and only interact through shared events?</description></item></channel></rss>