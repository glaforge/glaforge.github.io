The article chronicles the author's personal journey and evolution regarding software testing, specifically detailing a recent conversion to Test-Driven Development (TDD) after years of working on projects that hindered such practices.

Initially, the author was familiar with the concept of unit tests but rarely had the opportunity to develop using a "test-first" approach. This limitation stemmed primarily from previous projects being "not pretty test-friendly," often characterized by pervasive static instances and a complete lack of Inversion of Control (IoC) or Dependency Injection (DI) principles. Additionally, the author found it challenging to write tests for web-based and GUI projects, acknowledging the need to explore specific HTTP and Swing testing frameworks. Due to these constraints, the author frequently resorted to less professional and inefficient testing methods, such as using `main` methods and `System.out.println()` statements, which made regression testing difficult and led to self-confessed "shame."

A contrasting experience came from the author's involvement as a developer on the Groovy scripting language pet project. Here, a "geniusly designed Groovy testing framework" ensured that testing was an integral part of development. However, even in this context, the author predominantly coded first and then wrote tests, not having fully adopted the test-first habit. The article notes that recent improvements to the Groovy build process, including the ability to launch a single test and the addition of a quick-test Maven goal, are now making "test-first" development more accessible within that project.

The pivotal shift towards embracing TDD occurred with a new project at the author's current company: a JMS (Java Message Service) implementation built over a Message-Oriented Middleware (MOM). The author seized this opportunity to take "first steps in TDD-land" and expressed considerable satisfaction with the initial results of this approach.

The first significant piece of software developed using a true test-first methodology was a small, embedded JNDI (Java Naming and Directory Interface) provider. This component was necessary for retrieving administered objects from a JNDI context. Recognizing a lack of extensive prior knowledge about implementing such a complex component, the author believed that testing it first would be a beneficial guide, and this indeed proved to be the case. The TDD process effectively "guide[d] my hand and my brain during the development process." As the author delved into the JNDI specification and read the Javadoc documentation, corresponding tests were systematically created to match the identified requirements. Concrete examples given include writing a test to ensure a method throws a `NullPointerException` (NPE) if the `Name` object is null, and another to verify that the `NamingEnumeration.hasMore()` method returns `false` when no more elements are present. This iterative, requirement-driven testing approach ensured that the author concluded the development with a "fair amount of tests that correspond to the spec."

The article concludes with a strong, delighted endorsement of TDD. The author describes the experience as "quite a pleasant and fruitful," admitting to now better understanding the enthusiasm of those "infected by the test-first virus." The TDD process, by forcing a deeper understanding of what is to be implemented, actively guides the developer and significantly boosts confidence in the resulting code. The seamless JUnit integration within IntelliJ IDEA, the author's preferred IDE, further enhances this positive experience, leading to satisfaction upon seeing the familiar "green bar" indicating successful tests. The author expresses a firm commitment to continue writing JUnit tests first whenever feasible and harbors aspirations of converting colleagues to the TDD approach. The article ends on a celebratory note, marking another successful test run.